{
  "key": "screensList",
  "value": [
    {
      "id": "SCR-001",
      "category": "イベント一覧",
      "screenName": "イベント一覧画面",
      "description": "開催予定のイベント一覧を表示する画面",
      "Screen components": "イベント検索フォーム、イベントカードリスト、ページネーション",
      "operatingProcedure": "1. イベントの検索・フィルタリング\n2. イベント詳細へのリンククリック\n3. ページ切り替え",
      "user": "全てのユーザー",
      "accessRight": "ゲストユーザー",
      "fileName": "events/index.tsx",
      "getData": "[{table:'events',items:['id','title','description','startDate','endDate','capacity','status']},{table:'eventTypes',items:['id','name']}]",
      "postData": "[]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"EventCard.tsx\",\"SearchForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "イベント一覧画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-002",
      "category": "イベント詳細",
      "screenName": "イベント詳細画面",
      "description": "個別のイベント詳細情報を表示する画面",
      "Screen components": "イベント詳細情報、参加申し込みフォーム、参加者数表示",
      "operatingProcedure": "1. イベント詳細の確認\n2. 参加申し込みボタンのクリック",
      "user": "全てのユーザー",
      "accessRight": "ゲストユーザー",
      "fileName": "events/[eventId]/index.tsx",
      "getData": "[{table:'events',items:['*']},{table:'eventTickets',items:['*']},{table:'venues',items:['*']}]",
      "postData": "[]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"EventDetailCard.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "イベント詳細画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-003",
      "category": "イベント登録",
      "screenName": "イベント作成画面",
      "description": "新規イベントを作成する画面",
      "Screen components": "イベント情報入力フォーム、チケット設定フォーム、参加者入力項目設定",
      "operatingProcedure": "1. イベント基本情報の入力\n2. チケット種別の設定\n3. 参加者入力項目の設定\n4. プレビュー確認\n5. 保存",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/create.tsx",
      "getData": "[]",
      "postData": "[{table:'events',items:['*']},{table:'eventTickets',items:['*']},{table:'eventFormItems',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"EventForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "イベント作成画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-001",
          "category": "イベント管理",
          "handleName": "イベント作成",
          "description": "新規イベントの作成と保存",
          "handleProcedure": "1. リクエストボディからイベント情報を取得\n2. バリデーション実行\n3. eventsテーブルに基本情報を保存\n4. チケット情報をticketsテーブルに保存\n5. 参加者入力項目設定を保存\n6. レスポンスとしてイベントIDを返却",
          "fileName": "api/events/create.ts",
          "relatedScreen": "SCR-003",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { act } from 'react-dom/test-utils';\nimport userEvent from '@testing-library/user-event';\nimport EventCreate from '@/pages/events/create';\nimport { Header } from '@/components/Header';\nimport { Footer } from '@/components/Footer';\nimport { EventForm } from '@/components/EventForm';\nimport axios from 'axios';\n\n// モック\njest.mock('@/components/Header');\njest.mock('@/components/Footer'); \njest.mock('@/components/EventForm');\njest.mock('axios');\n\ndescribe('EventCreate', () => {\n  const mockUser = {\n    id: '1',\n    name: 'テストユーザー'\n  };\n\n  beforeEach(() => {\n    (Header as jest.Mock).mockImplementation(() => <div data-testid=\"mock-header\" />);\n    (Footer as jest.Mock).mockImplementation(() => <div data-testid=\"mock-footer\" />);\n    (EventForm as jest.Mock).mockImplementation(({ onSubmit }) => (\n      <form data-testid=\"mock-event-form\" onSubmit={onSubmit}>\n        <button type=\"submit\">保存</button>\n      </form>\n    ));\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('正しくレンダリングされること', () => {\n    render(<EventCreate />);\n    \n    expect(screen.getByTestId('mock-header')).toBeInTheDocument();\n    expect(screen.getByTestId('mock-event-form')).toBeInTheDocument();\n    expect(screen.getByTestId('mock-footer')).toBeInTheDocument();\n    expect(screen.getByText('イベント作成')).toBeInTheDocument();\n  });\n\n  it('フォーム送信時に正しくAPIが呼ばれること', async () => {\n    const mockEventData = {\n      title: 'テストイベント',\n      description: 'テスト説明',\n      startDate: '2024-01-01',\n      endDate: '2024-01-02',\n      tickets: [\n        { name: '一般チケット', price: 1000 }\n      ]\n    };\n\n    (axios.post as jest.Mock).mockResolvedValue({\n      data: { id: '123' }\n    });\n\n    render(<EventCreate />);\n\n    await act(async () => {\n      const form = screen.getByTestId('mock-event-form');\n      fireEvent.submit(form);\n    });\n\n    await waitFor(() => {\n      expect(axios.post).toHaveBeenCalledWith('/api/events/create', expect.any(Object));\n      expect(mockNextRouter.push).toHaveBeenCalledWith('/events/123');\n    });\n  });\n\n  it('APIエラー時にエラーメッセージが表示されること', async () => {\n    (axios.post as jest.Mock).mockRejectedValue({\n      response: {\n        data: { message: 'エラーが発生しました' }\n      }\n    });\n\n    render(<EventCreate />);\n\n    await act(async () => {\n      const form = screen.getByTestId('mock-event-form');\n      fireEvent.submit(form);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n    });\n  });\n\n  it('未ログイン時にログイン画面にリダイレクトされること', async () => {\n    render(<EventCreate />);\n\n    await waitFor(() => {\n      expect(mockNextRouter.push).toHaveBeenCalledWith('/login');\n    });\n  });\n\n  it('プレビューモードを切り替えられること', async () => {\n    render(<EventCreate />);\n\n    const previewButton = screen.getByText('プレビュー');\n    await userEvent.click(previewButton);\n\n    expect(screen.getByTestId('preview-mode')).toBeInTheDocument();\n\n    const editButton = screen.getByText('編集に戻る');\n    await userEvent.click(editButton);\n\n    expect(screen.queryByTestId('preview-mode')).not.toBeInTheDocument();\n  });\n\n  it('フォームの入力値が保持されること', async () => {\n    render(<EventCreate />);\n\n    const titleInput = screen.getByLabelText('イベント名');\n    await userEvent.type(titleInput, 'テストイベント');\n\n    const descInput = screen.getByLabelText('説明');\n    await userEvent.type(descInput, 'テスト説明');\n\n    expect(titleInput).toHaveValue('テストイベント');\n    expect(descInput).toHaveValue('テスト説明');\n  });\n\n  it('必須項目が未入力の場合にバリデーションエラーが表示されること', async () => {\n    render(<EventCreate />);\n\n    const submitButton = screen.getByText('保存');\n    await userEvent.click(submitButton);\n\n    expect(screen.getByText('イベント名は必須です')).toBeInTheDocument();\n    expect(screen.getByText('開催日時は必須です')).toBeInTheDocument();\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-004",
      "category": "イベント管理",
      "screenName": "イベント編集画面",
      "description": "既存イベントの情報を編集する画面",
      "Screen components": "イベント情報編集フォーム、チケット設定編集フォーム",
      "operatingProcedure": "1. 既存情報の編集\n2. プレビュー確認\n3. 更新",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/edit.tsx",
      "getData": "[{table:'events',items:['*']},{table:'eventTickets',items:['*']},{table:'eventFormItems',items:['*']}]",
      "postData": "[{table:'events',items:['*']},{table:'eventTickets',items:['*']},{table:'eventFormItems',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"EventForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "イベント編集画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-002",
          "category": "イベント管理",
          "handleName": "イベント更新",
          "description": "既存イベントの情報更新",
          "handleProcedure": "1. イベントIDの有効性確認\n2. 更新権限の確認\n3. リクエストボディのバリデーション\n4. eventsテーブルの更新\n5. 関連するチケット情報の更新\n6. 更新結果を返却",
          "fileName": "api/events/[eventId]/update.ts",
          "relatedScreen": "SCR-004",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport EventEdit from '@/pages/events/[eventId]/edit';\nimport '@testing-library/jest-dom';\nimport userEvent from '@testing-library/user-event';\nimport { useRouter } from 'next/navigation';\n\n// モックデータ\nconst mockEvent = {\n  id: '1234',\n  title: 'テストイベント',\n  description: 'テストイベントの説明',\n  startDateTime: '2024-01-01T10:00:00',\n  endDateTime: '2024-01-01T17:00:00',\n  venue: {\n    name: 'テスト会場',\n    address: '東京都渋谷区'\n  },\n  tickets: [\n    {\n      id: '1',\n      name: '一般チケット',\n      price: 1000,\n      capacity: 100\n    }\n  ]\n};\n\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n  usePathname: () => '/events/1234/edit',\n  useSearchParams: () => new URLSearchParams()\n}));\n\ndescribe('EventEdit', () => {\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockImplementation(() => ({\n      push: jest.fn(),\n      query: { eventId: '1234' }\n    }));\n\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve(mockEvent)\n      })\n    ) as jest.Mock;\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('イベント情報が正しく表示される', async () => {\n    render(<EventEdit />);\n    \n    await waitFor(() => {\n      expect(screen.getByDisplayValue('テストイベント')).toBeInTheDocument();\n      expect(screen.getByDisplayValue('テストイベントの説明')).toBeInTheDocument();\n    });\n  });\n\n  it('入力フォームの値を更新できる', async () => {\n    render(<EventEdit />);\n\n    await waitFor(() => {\n      const titleInput = screen.getByLabelText('イベントタイトル') as HTMLInputElement;\n      fireEvent.change(titleInput, { target: { value: '更新後のタイトル' } });\n      expect(titleInput.value).toBe('更新後のタイトル');\n    });\n  });\n\n  it('フォーム送信時にAPIが呼ばれる', async () => {\n    const mockFetch = jest.fn(() => \n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve({ success: true })\n      })\n    );\n    global.fetch = mockFetch;\n\n    render(<EventEdit />);\n\n    await waitFor(() => {\n      const submitButton = screen.getByRole('button', { name: '更新する' });\n      fireEvent.click(submitButton);\n    });\n\n    await waitFor(() => {\n      expect(mockFetch).toHaveBeenCalled();\n    });\n  });\n\n  it('バリデーションエラーが表示される', async () => {\n    render(<EventEdit />);\n\n    await waitFor(() => {\n      const titleInput = screen.getByLabelText('イベントタイトル') as HTMLInputElement;\n      fireEvent.change(titleInput, { target: { value: '' } });\n      \n      const submitButton = screen.getByRole('button', { name: '更新する' });\n      fireEvent.click(submitButton);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('タイトルは必須です')).toBeInTheDocument();\n    });\n  });\n\n  it('APIエラー時にエラーメッセージが表示される', async () => {\n    global.fetch = jest.fn(() =>\n      Promise.reject(new Error('API Error'))\n    ) as jest.Mock;\n\n    render(<EventEdit />);\n\n    await waitFor(() => {\n      const submitButton = screen.getByRole('button', { name: '更新する' });\n      fireEvent.click(submitButton);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('更新に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  it('キャンセルボタンクリックで一覧画面に戻る', async () => {\n    const mockPush = jest.fn();\n    (useRouter as jest.Mock).mockImplementation(() => ({\n      push: mockPush,\n      query: { eventId: '1234' }\n    }));\n\n    render(<EventEdit />);\n\n    const cancelButton = screen.getByRole('button', { name: 'キャンセル' });\n    fireEvent.click(cancelButton);\n\n    expect(mockPush).toHaveBeenCalledWith('/events');\n  });\n\n  it('日時入力が正しく機能する', async () => {\n    render(<EventEdit />);\n\n    await waitFor(() => {\n      const startDateInput = screen.getByLabelText('開始日時') as HTMLInputElement;\n      const endDateInput = screen.getByLabelText('終了日時') as HTMLInputElement;\n\n      fireEvent.change(startDateInput, { target: { value: '2024-01-01T10:00' } });\n      fireEvent.change(endDateInput, { target: { value: '2024-01-01T17:00' } });\n\n      expect(startDateInput.value).toBe('2024-01-01T10:00');\n      expect(endDateInput.value).toBe('2024-01-01T17:00');\n    });\n  });\n\n  it('チケット情報の更新が正しく機能する', async () => {\n    render(<EventEdit />);\n\n    await waitFor(() => {\n      const ticketNameInput = screen.getByLabelText('チケット名') as HTMLInputElement;\n      const ticketPriceInput = screen.getByLabelText('価格') as HTMLInputElement;\n      \n      fireEvent.change(ticketNameInput, { target: { value: '更新後のチケット' } });\n      fireEvent.change(ticketPriceInput, { target: { value: '2000' } });\n\n      expect(ticketNameInput.value).toBe('更新後のチケット');\n      expect(ticketPriceInput.value).toBe('2000');\n    });\n  });\n\n  it('プレビューモードが正しく機能する', async () => {\n    render(<EventEdit />);\n\n    const previewButton = screen.getByRole('button', { name: 'プレビュー' });\n    fireEvent.click(previewButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('プレビューモード')).toBeInTheDocument();\n      expect(screen.getByText('テストイベント')).toBeInTheDocument();\n      expect(screen.getByText('テストイベントの説明')).toBeInTheDocument();\n    });\n  });\n\n  it('フォーム送信時のローディング状態が正しく表示される', async () => {\n    render(<EventEdit />);\n\n    const submitButton = screen.getByRole('button', { name: '更新する' });\n    fireEvent.click(submitButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('更新中...')).toBeInTheDocument();\n    });\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-005",
      "category": "参加登録",
      "screenName": "イベント参加登録画面",
      "description": "イベントへの参加登録を行う画面",
      "Screen components": "参加者情報入力フォーム、チケット選択",
      "operatingProcedure": "1. チケット種別の選択\n2. 参加者情報の入力\n3. 確認\n4. 登録",
      "user": "イベント参加者",
      "accessRight": "ゲストユーザー",
      "fileName": "events/[eventId]/register.tsx",
      "getData": "[{table:'events',items:['*']},{table:'eventTickets',items:['*']},{table:'eventFormItems',items:['*']}]",
      "postData": "[{table:'participants',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"RegistrationForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "イベント参加登録画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-003",
          "category": "参加登録",
          "handleName": "参加登録処理",
          "description": "イベントへの参加登録の処理",
          "handleProcedure": "1. チケット在庫確認\n2. 参加者情報のバリデーション\n3. registrationsテーブルに登録\n4. チケット在庫数の更新\n5. 確認メールの送信\n6. 登録完了通知の返却",
          "fileName": "api/events/[eventId]/register.ts",
          "relatedScreen": "SCR-005",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { act } from 'react-dom/test-utils'\nimport Register from '@/pages/events/[eventId]/register'\nimport '@testing-library/jest-dom'\nimport { useRouter } from 'next/navigation'\n\n// モックデータ\nconst mockEvent = {\n  id: 'event-1',\n  title: 'テストイベント',\n  description: 'テストイベントの説明',\n  startDateTime: '2024-01-01T10:00:00',\n  endDateTime: '2024-01-01T17:00:00',\n  venue: { name: 'テスト会場', address: '東京都渋谷区' }\n}\n\nconst mockTickets = [\n  {\n    id: 'ticket-1',\n    name: '一般チケット',\n    price: 1000,\n    description: '一般参加者向けチケット',\n    capacity: 100,\n    remainingCount: 50\n  },\n  {\n    id: 'ticket-2', \n    name: '学生チケット',\n    price: 500,\n    description: '学生向けチケット',\n    capacity: 50,\n    remainingCount: 30\n  }\n]\n\nconst mockFormItems = [\n  {\n    id: 'name',\n    type: 'text',\n    label: '氏名',\n    required: true\n  },\n  {\n    id: 'email',\n    type: 'email', \n    label: 'メールアドレス',\n    required: true\n  }\n]\n\n// モック関数の設定\njest.mock('next/navigation')\nconst mockUseRouter = useRouter as jest.Mock\n\ndescribe('Register Page', () => {\n  beforeEach(() => {\n    mockUseRouter.mockImplementation(() => ({\n      push: jest.fn(),\n      query: { eventId: 'event-1' }\n    }))\n\n    global.fetch = jest.fn((url) => {\n      if(url.includes('/api/events/event-1')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve(mockEvent)\n        })\n      } else if(url.includes('/api/events/event-1/tickets')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve(mockTickets)\n        })\n      } else if(url.includes('/api/events/event-1/form-items')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve(mockFormItems)\n        })\n      }\n      return Promise.reject(new Error('Not found'))\n    }) as jest.Mock\n  })\n\n  it('正しくページが表示される', async () => {\n    await act(async () => {\n      render(<Register />)\n    })\n\n    expect(screen.getByText('テストイベント')).toBeInTheDocument()\n    expect(screen.getByText('一般チケット')).toBeInTheDocument()\n    expect(screen.getByText('学生チケット')).toBeInTheDocument()\n    expect(screen.getByLabelText('氏名')).toBeInTheDocument()\n    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument()\n  })\n\n  it('フォームに必須項目が未入力の場合エラーが表示される', async () => {\n    await act(async () => {\n      render(<Register />)\n    })\n\n    const submitButton = screen.getByRole('button', { name: '参加登録する' })\n    \n    await act(async () => {\n      fireEvent.click(submitButton)\n    })\n\n    expect(screen.getByText('氏名を入力してください')).toBeInTheDocument()\n    expect(screen.getByText('メールアドレスを入力してください')).toBeInTheDocument()\n  })\n\n  it('フォームに正しく入力して送信できる', async () => {\n    global.fetch = jest.fn().mockImplementationOnce((url) => {\n      if(url.includes('/api/events/event-1/register')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve({ success: true })\n        })\n      }\n      return Promise.reject(new Error('Not found'))\n    }) as jest.Mock\n\n    await act(async () => {\n      render(<Register />)\n    })\n\n    const nameInput = screen.getByLabelText('氏名')\n    const emailInput = screen.getByLabelText('メールアドレス')\n    const ticketSelect = screen.getByLabelText('チケット種別')\n    const submitButton = screen.getByRole('button', { name: '参加登録する' })\n\n    await act(async () => {\n      fireEvent.change(nameInput, { target: { value: 'テスト太郎' } })\n      fireEvent.change(emailInput, { target: { value: 'test@example.com' } })\n      fireEvent.change(ticketSelect, { target: { value: 'ticket-1' } })\n      fireEvent.click(submitButton)\n    })\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith(\n        expect.stringContaining('/api/events/event-1/register'),\n        expect.objectContaining({\n          method: 'POST',\n          body: JSON.stringify({\n            ticketId: 'ticket-1',\n            participantInfo: {\n              name: 'テスト太郎',\n              email: 'test@example.com'\n            }\n          })\n        })\n      )\n    })\n  })\n\n  it('チケットが売り切れの場合エラーメッセージが表示される', async () => {\n    const soldOutTickets = [\n      {\n        ...mockTickets[0],\n        remainingCount: 0\n      }\n    ]\n\n    global.fetch = jest.fn((url) => {\n      if(url.includes('/api/events/event-1/tickets')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve(soldOutTickets)\n        })\n      }\n      return Promise.reject(new Error('Not found'))\n    }) as jest.Mock\n\n    await act(async () => {\n      render(<Register />)\n    })\n\n    expect(screen.getByText('このチケットは売り切れです')).toBeInTheDocument()\n  })\n\n  it('APIエラー時にエラーメッセージが表示される', async () => {\n    global.fetch = jest.fn().mockRejectedValueOnce(new Error('API Error'))\n\n    await act(async () => {\n      render(<Register />)\n    })\n\n    expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument()\n  })\n\n  it('登録完了後に完了画面に遷移する', async () => {\n    const mockPush = jest.fn()\n    mockUseRouter.mockImplementation(() => ({\n      push: mockPush,\n      query: { eventId: 'event-1' }\n    }))\n\n    global.fetch = jest.fn().mockImplementationOnce((url) => {\n      if(url.includes('/api/events/event-1/register')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve({ success: true })\n        })\n      }\n      return Promise.reject(new Error('Not found'))\n    }) as jest.Mock\n\n    await act(async () => {\n      render(<Register />)\n    })\n\n    const nameInput = screen.getByLabelText('氏名')\n    const emailInput = screen.getByLabelText('メールアドレス')\n    const submitButton = screen.getByRole('button', { name: '参加登録する' })\n\n    await act(async () => {\n      fireEvent.change(nameInput, { target: { value: 'テスト太郎' } })\n      fireEvent.change(emailInput, { target: { value: 'test@example.com' } })\n      fireEvent.click(submitButton)\n    })\n\n    await waitFor(() => {\n      expect(mockPush).toHaveBeenCalledWith(\n        expect.stringContaining('/events/event-1/register/complete')\n      )\n    })\n  })\n})\n```"
        }
      ]
    },
    {
      "id": "SCR-006",
      "category": "参加者管理",
      "screenName": "参加者一覧画面",
      "description": "イベント参加者の一覧を管理する画面",
      "Screen components": "参加者リスト、検索フィルター、一括操作ボタン",
      "operatingProcedure": "1. 参加者の検索・フィルタリング\n2. 参加者情報の確認\n3. CSV出力\n4. リマインドメール送信",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/participants/index.tsx",
      "getData": "[{table:'participants',items:['*']},{table:'events',items:['*']}]",
      "postData": "[]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"ParticipantList.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "参加者一覧画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-004",
          "category": "参加者管理",
          "handleName": "参加者一覧取得",
          "description": "イベント参加者の一覧データ取得",
          "handleProcedure": "1. アクセス権限の確認\n2. クエリパラメータによるフィルタリング条件の解析\n3. registrationsテーブルから参加者データ取得\n4. ページネーション処理\n5. 参加者一覧データの返却",
          "fileName": "api/events/[eventId]/participants/list.ts",
          "relatedScreen": "SCR-006",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport ParticipantListPage from '@/pages/events/[eventId]/participants/index';\nimport { useRouter } from 'next/navigation';\n\n// モックデータ\nconst mockParticipants = [\n  {\n    id: '1',\n    name: 'テスト太郎',\n    email: 'test1@example.com',\n    ticketType: '一般',\n    status: '参加確定',\n    registeredAt: '2024-01-01T10:00:00'\n  },\n  {\n    id: '2', \n    name: 'テスト花子',\n    email: 'test2@example.com',\n    ticketType: '学生',\n    status: 'キャンセル',\n    registeredAt: '2024-01-02T11:00:00'\n  }\n];\n\nconst mockEventData = {\n  id: 'event-1',\n  title: 'テストイベント',\n  date: '2024-01-15'\n};\n\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn()\n}));\n\n// APIコールのモック\njest.mock('axios', () => ({\n  get: jest.fn(),\n  post: jest.fn()\n}));\n\ndescribe('ParticipantListPage', () => {\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockImplementation(() => ({\n      push: jest.fn(),\n      query: { eventId: 'event-1' }\n    }));\n    \n    global.axios.get.mockImplementation((url) => {\n      if(url.includes('/api/events/event-1/participants')) {\n        return Promise.resolve({ data: { participants: mockParticipants } });\n      }\n      if(url.includes('/api/events/event-1')) {\n        return Promise.resolve({ data: mockEventData });\n      }\n      return Promise.resolve({ data: {} });\n    });\n  });\n\n  it('参加者一覧が正しく表示される', async () => {\n    render(<ParticipantListPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('テスト太郎')).toBeInTheDocument();\n      expect(screen.getByText('テスト花子')).toBeInTheDocument();\n    });\n  });\n\n  it('検索フィルターが機能する', async () => {\n    render(<ParticipantListPage />);\n\n    const searchInput = screen.getByPlaceholderText('参加者を検索');\n    fireEvent.change(searchInput, { target: { value: '太郎' } });\n\n    await waitFor(() => {\n      expect(screen.getByText('テスト太郎')).toBeInTheDocument();\n      expect(screen.queryByText('テスト花子')).not.toBeInTheDocument();\n    });\n  });\n\n  it('CSVエクスポートボタンが機能する', async () => {\n    render(<ParticipantListPage />);\n\n    const exportButton = screen.getByText('CSVエクスポート');\n    fireEvent.click(exportButton);\n\n    await waitFor(() => {\n      expect(global.axios.post).toHaveBeenCalledWith(\n        '/api/events/event-1/participants/export',\n        expect.any(Object)\n      );\n    });\n  });\n\n  it('リマインドメール送信ボタンが機能する', async () => {\n    render(<ParticipantListPage />);\n\n    const sendMailButton = screen.getByText('リマインドメール送信');\n    fireEvent.click(sendMailButton);\n\n    await waitFor(() => {\n      expect(global.mockNextRouter.push).toHaveBeenCalledWith(\n        '/events/event-1/mail/reminder'\n      );\n    });\n  });\n\n  it('参加者ステータスの一括更新が機能する', async () => {\n    render(<ParticipantListPage />);\n\n    // 参加者選択\n    const checkboxes = screen.getAllByRole('checkbox');\n    fireEvent.click(checkboxes[0]);\n\n    const bulkActionButton = screen.getByText('一括操作');\n    fireEvent.click(bulkActionButton);\n\n    const updateStatusButton = screen.getByText('ステータス更新');\n    fireEvent.click(updateStatusButton);\n\n    await waitFor(() => {\n      expect(global.axios.post).toHaveBeenCalledWith(\n        '/api/events/event-1/participants/bulk-update',\n        expect.any(Object)\n      );\n    });\n  });\n\n  it('エラー時にエラーメッセージが表示される', async () => {\n    global.axios.get.mockRejectedValueOnce(new Error('データ取得に失敗しました'));\n    \n    render(<ParticipantListPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n    });\n  });\n\n  it('ローディング状態が表示される', () => {\n    render(<ParticipantListPage />);\n    expect(screen.getByText('読み込み中...')).toBeInTheDocument();\n  });\n\n  it('参加者が0人の場合に適切なメッセージが表示される', async () => {\n    global.axios.get.mockImplementationOnce(() => \n      Promise.resolve({ data: { participants: [] } })\n    );\n\n    render(<ParticipantListPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('参加者がいません')).toBeInTheDocument();\n    });\n  });\n\n  it('参加者詳細画面へ遷移できる', async () => {\n    render(<ParticipantListPage />);\n\n    await waitFor(() => {\n      const participantRow = screen.getByText('テスト太郎').closest('tr');\n      fireEvent.click(participantRow!);\n    });\n\n    expect(global.mockNextRouter.push).toHaveBeenCalledWith(\n      '/events/event-1/participants/1'\n    );\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-007",
      "category": "ログイン",
      "screenName": "ログイン画面",
      "description": "システムへのログインを行う画面",
      "Screen components": "ログインフォーム、パスワードリセットリンク",
      "operatingProcedure": "1. メールアドレス入力\n2. パスワード入力\n3. ログインボタンクリック",
      "user": "イベント主催者",
      "accessRight": "ゲストユーザー",
      "fileName": "auth/login.tsx",
      "getData": "[]",
      "postData": "[{table:'users',items:['email','password']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"LoginForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "ログイン画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-005",
          "category": "認証",
          "handleName": "ログイン認証",
          "description": "ユーザーログインの認証処理",
          "handleProcedure": "1. メールアドレスとパスワードの取得\n2. 認証情報の検証\n3. JWTトークンの生成\n4. ユーザー情報とトークンの返却",
          "fileName": "api/auth/login.ts",
          "relatedScreen": "SCR-007",
          "relatedFrontendCode": "```typescript\nimport { render, screen, waitFor, fireEvent } from '@testing-library/react';\nimport { act } from 'react-dom/test-utils';\nimport Login from '@/pages/auth/login';\nimport '@testing-library/jest-dom';\nimport { useRouter } from 'next/navigation';\n\n// モック設定\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n}));\n\ndescribe('Login画面', () => {\n  const mockPush = jest.fn();\n\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockImplementation(() => ({\n      push: mockPush,\n    }));\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('ログインフォームが表示される', () => {\n    render(<Login />);\n    expect(screen.getByRole('textbox', { name: /メールアドレス/i })).toBeInTheDocument();\n    expect(screen.getByLabelText(/パスワード/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /ログイン/i })).toBeInTheDocument();\n  });\n\n  it('バリデーションエラーが表示される', async () => {\n    render(<Login />);\n    \n    const submitButton = screen.getByRole('button', { name: /ログイン/i });\n    \n    await act(async () => {\n      fireEvent.click(submitButton);\n    });\n\n    expect(screen.getByText('メールアドレスを入力してください')).toBeInTheDocument();\n    expect(screen.getByText('パスワードを入力してください')).toBeInTheDocument();\n  });\n\n  it('ログイン成功時にダッシュボードへリダイレクトする', async () => {\n    render(<Login />);\n\n    const emailInput = screen.getByRole('textbox', { name: /メールアドレス/i });\n    const passwordInput = screen.getByLabelText(/パスワード/i);\n    const submitButton = screen.getByRole('button', { name: /ログイン/i });\n\n    await act(async () => {\n      fireEvent.change(emailInput, { target: { value: 'test@example.com' } });\n      fireEvent.change(passwordInput, { target: { value: 'password123' } });\n      fireEvent.click(submitButton);\n    });\n\n    await waitFor(() => {\n      expect(mockPush).toHaveBeenCalledWith('/dashboard');\n    });\n  });\n\n  it('ログイン失敗時にエラーメッセージが表示される', async () => {\n    global.fetch = jest.fn(() =>\n      Promise.reject('Login failed')\n    ) as jest.Mock;\n\n    render(<Login />);\n\n    const emailInput = screen.getByRole('textbox', { name: /メールアドレス/i });\n    const passwordInput = screen.getByLabelText(/パスワード/i);\n    const submitButton = screen.getByRole('button', { name: /ログイン/i });\n\n    await act(async () => {\n      fireEvent.change(emailInput, { target: { value: 'test@example.com' } });\n      fireEvent.change(passwordInput, { target: { value: 'wrongpassword' } });\n      fireEvent.click(submitButton);\n    });\n\n    expect(screen.getByText('ログインに失敗しました')).toBeInTheDocument();\n  });\n\n  it('パスワードリセットリンクが機能する', async () => {\n    render(<Login />);\n    \n    const resetLink = screen.getByText('パスワードをお忘れの方');\n    \n    await act(async () => {\n      fireEvent.click(resetLink);\n    });\n\n    expect(mockPush).toHaveBeenCalledWith('/auth/reset-password');\n  });\n\n  it('メールアドレスの形式バリデーションが機能する', async () => {\n    render(<Login />);\n\n    const emailInput = screen.getByRole('textbox', { name: /メールアドレス/i });\n    const submitButton = screen.getByRole('button', { name: /ログイン/i });\n\n    await act(async () => {\n      fireEvent.change(emailInput, { target: { value: 'invalid-email' } });\n      fireEvent.click(submitButton);\n    });\n\n    expect(screen.getByText('有効なメールアドレスを入力してください')).toBeInTheDocument();\n  });\n\n  it('パスワードの最小文字数バリデーションが機能する', async () => {\n    render(<Login />);\n\n    const passwordInput = screen.getByLabelText(/パスワード/i);\n    const submitButton = screen.getByRole('button', { name: /ログイン/i });\n\n    await act(async () => {\n      fireEvent.change(passwordInput, { target: { value: '123' } });\n      fireEvent.click(submitButton);\n    });\n\n    expect(screen.getByText('パスワードは8文字以上で入力してください')).toBeInTheDocument();\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-008",
      "category": "アカウント管理",
      "screenName": "アカウント登録画面",
      "description": "新規アカウントを作成する画面",
      "Screen components": "アカウント情報入力フォーム",
      "operatingProcedure": "1. 必要情報の入力\n2. 利用規約の確認\n3. 登録",
      "user": "イベント主催者",
      "accessRight": "ゲストユーザー",
      "fileName": "auth/register.tsx",
      "getData": "[]",
      "postData": "[{table:'users',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"RegisterForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "アカウント登録画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-009",
      "category": "出欠管理",
      "screenName": "出欠確認画面",
      "description": "イベント当日の参加者出欠を管理する画面",
      "Screen components": "参加者リスト、出欠入力フォーム、QRコードリーダー",
      "operatingProcedure": "1. QRコード読み取り\n2. 手動での出欠入力\n3. 備考記入",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/attendance.tsx",
      "getData": "[{table:'participants',items:['*']},{table:'attendance',items:['*']}]",
      "postData": "[{table:'attendance',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"AttendanceList.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "出欠確認画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-007",
          "category": "出欠管理",
          "handleName": "出欠状態更新",
          "description": "参加者の出欠状態を更新",
          "handleProcedure": "1. 参加者IDの確認\n2. 出欠データのバリデーション\n3. registrationsテーブルの出欠状態更新\n4. 更新履歴の記録\n5. 更新結果の返却",
          "fileName": "api/events/[eventId]/attendance/update.ts",
          "relatedScreen": "SCR-009",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { useRouter } from 'next/navigation'\nimport Attendance from '@/pages/events/[eventId]/attendance'\nimport '@testing-library/jest-dom'\nimport { useState as useStateMock } from 'react'\n\n// モックデータ\nconst mockParticipants = [\n  {\n    id: '1',\n    name: '山田太郎',\n    email: 'yamada@test.com',\n    status: '出席予定'\n  },\n  {\n    id: '2', \n    name: '鈴木花子',\n    email: 'suzuki@test.com',\n    status: '欠席'\n  }\n]\n\nconst mockAttendance = [\n  {\n    participantId: '1',\n    status: '出席',\n    note: ''\n  }\n]\n\n// モック\njest.mock('next/navigation')\njest.mock('react', () => ({\n  ...jest.requireActual('react'),\n  useState: jest.fn()\n}))\n\nconst mockSetParticipants = jest.fn()\nconst mockSetAttendance = jest.fn()\n\ndescribe('出欠確認画面', () => {\n  beforeEach(() => {\n    ;(useStateMock as jest.Mock)\n      .mockImplementationOnce([mockParticipants, mockSetParticipants])\n      .mockImplementationOnce([mockAttendance, mockSetAttendance])\n      \n    ;(useRouter as jest.Mock).mockReturnValue({\n      query: { eventId: '1' }\n    })\n  })\n\n  it('参加者リストが表示される', () => {\n    render(<Attendance />)\n    expect(screen.getByText('山田太郎')).toBeInTheDocument()\n    expect(screen.getByText('鈴木花子')).toBeInTheDocument()\n  })\n\n  it('QRコードリーダーボタンが機能する', () => {\n    render(<Attendance />)\n    const qrButton = screen.getByText('QRコード読取')\n    fireEvent.click(qrButton)\n    expect(screen.getByTestId('qr-reader')).toBeInTheDocument()\n  })\n\n  it('手動で出欠入力ができる', async () => {\n    render(<Attendance />)\n    \n    const statusSelect = screen.getByLabelText('出欠状態')\n    fireEvent.change(statusSelect, { target: { value: '出席' }})\n\n    const noteInput = screen.getByLabelText('備考')\n    fireEvent.change(noteInput, { target: { value: 'テスト備考' }})\n\n    const submitButton = screen.getByText('保存')\n    fireEvent.click(submitButton)\n\n    await waitFor(() => {\n      expect(mockSetAttendance).toHaveBeenCalledWith(\n        expect.arrayContaining([\n          expect.objectContaining({\n            status: '出席',\n            note: 'テスト備考'\n          })\n        ])\n      )\n    })\n  })\n\n  it('エラー時にエラーメッセージが表示される', async () => {\n    const mockFetch = jest.spyOn(global, 'fetch')\n    mockFetch.mockRejectedValueOnce(new Error('API Error'))\n\n    render(<Attendance />)\n    \n    const submitButton = screen.getByText('保存')\n    fireEvent.click(submitButton)\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument()\n    })\n  })\n\n  it('参加者の検索ができる', () => {\n    render(<Attendance />)\n    \n    const searchInput = screen.getByPlaceholderText('参加者検索')\n    fireEvent.change(searchInput, { target: { value: '山田' }})\n\n    expect(screen.getByText('山田太郎')).toBeInTheDocument()\n    expect(screen.queryByText('鈴木花子')).not.toBeInTheDocument()\n  })\n\n  it('集計情報が表示される', () => {\n    render(<Attendance />)\n    expect(screen.getByText('出席者数:')).toBeInTheDocument()\n    expect(screen.getByText('欠席者数:')).toBeInTheDocument()\n  })\n\n  it('CSVエクスポートができる', async () => {\n    render(<Attendance />)\n    \n    const exportButton = screen.getByText('CSVエクスポート')\n    fireEvent.click(exportButton)\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith(\n        expect.stringContaining('/api/events/1/attendance/export'),\n        expect.any(Object)\n      )\n    })\n  })\n})\n```"
        }
      ]
    },
    {
      "id": "SCR-010",
      "category": "アンケート管理",
      "screenName": "アンケート作成画面",
      "description": "イベント後のアンケートを作成する画面",
      "Screen components": "アンケート項目設定フォーム、プレビュー表示",
      "operatingProcedure": "1. アンケート項目の設定\n2. 必須項目の指定\n3. プレビュー確認\n4. 保存",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/survey/create.tsx",
      "getData": "[{table:'events',items:['*']}]",
      "postData": "[{table:'surveys',items:['*']},{table:'surveyQuestions',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"SurveyForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "アンケート作成画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-011",
      "category": "アンケート管理",
      "screenName": "アンケート回答画面",
      "description": "参加者がアンケートに回答する画面",
      "Screen components": "アンケート回答フォーム、進捗表示",
      "operatingProcedure": "1. アンケート項目への回答入力\n2. 確認\n3. 送信",
      "user": "イベント参加者",
      "accessRight": "ゲストユーザー",
      "fileName": "events/[eventId]/survey/answer.tsx",
      "getData": "[{table:'surveys',items:['*']},{table:'surveyQuestions',items:['*']}]",
      "postData": "[{table:'surveyAnswers',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"SurveyAnswerForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "アンケート回答画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-006",
          "category": "アンケート管理",
          "handleName": "アンケート回答保存",
          "description": "参加者のアンケート回答を保存",
          "handleProcedure": "1. 回答権限の確認\n2. 回答データのバリデーション\n3. survey_responsesテーブルへの保存\n4. 回答完了通知の送信\n5. 保存結果の返却",
          "fileName": "api/events/[eventId]/survey/submit.ts",
          "relatedScreen": "SCR-011",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport userEvent from '@testing-library/user-event';\nimport SurveyAnswer from '@/pages/events/[eventId]/survey/answer';\n\n// モックデータ\nconst mockSurveyData = {\n  id: \"test-survey-id\",\n  title: \"テストアンケート\",\n  description: \"テストアンケートの説明\",\n  questions: [\n    {\n      id: \"q1\",\n      type: \"text\",\n      required: true,\n      question: \"ご意見をお聞かせください\"\n    },\n    {\n      id: \"q2\", \n      type: \"radio\",\n      required: true,\n      question: \"満足度を教えてください\",\n      options: [\"とても満足\", \"満足\", \"普通\", \"不満\"]\n    }\n  ]\n};\n\n// モック\njest.mock('@/components/Header', () => {\n  return function DummyHeader() {\n    return <div data-testid=\"mock-header\">Header</div>;\n  };\n});\n\njest.mock('@/components/Footer', () => {\n  return function DummyFooter() {\n    return <div data-testid=\"mock-footer\">Footer</div>;\n  };\n});\n\njest.mock('@/components/SurveyAnswerForm', () => {\n  return function DummySurveyAnswerForm({ onSubmit }: {onSubmit: (data: any) => void}) {\n    return (\n      <form onSubmit={(e) => {\n        e.preventDefault();\n        onSubmit({answer1: \"test\", answer2: \"満足\"});\n      }}>\n        <input data-testid=\"answer1\" />\n        <select data-testid=\"answer2\">\n          <option value=\"満足\">満足</option>\n        </select>\n        <button type=\"submit\">送信</button>\n      </form>\n    );\n  };\n});\n\ndescribe('SurveyAnswer', () => {\n  beforeEach(() => {\n    // APIレスポンスのモック\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve(mockSurveyData),\n      })\n    ) as jest.Mock;\n  });\n\n  it('正しくレンダリングされること', async () => {\n    render(<SurveyAnswer />);\n    \n    expect(screen.getByTestId('mock-header')).toBeInTheDocument();\n    expect(screen.getByTestId('mock-footer')).toBeInTheDocument();\n    await waitFor(() => {\n      expect(screen.getByTestId('answer1')).toBeInTheDocument();\n    });\n  });\n\n  it('アンケートフォームが送信できること', async () => {\n    const mockPost = jest.spyOn(global, 'fetch');\n    render(<SurveyAnswer />);\n\n    await waitFor(() => {\n      expect(screen.getByText('送信')).toBeInTheDocument();\n    });\n\n    fireEvent.click(screen.getByText('送信'));\n\n    await waitFor(() => {\n      expect(mockPost).toHaveBeenCalledWith(\n        expect.any(String),\n        expect.objectContaining({\n          method: 'POST',\n          body: expect.any(String)\n        })\n      );\n    });\n  });\n\n  it('エラー時にエラーメッセージが表示されること', async () => {\n    global.fetch = jest.fn(() =>\n      Promise.reject(new Error('API Error'))\n    ) as jest.Mock;\n\n    render(<SurveyAnswer />);\n\n    await waitFor(() => {\n      expect(screen.getByText(/エラーが発生しました/i)).toBeInTheDocument();\n    });\n  });\n\n  it('送信成功時に完了メッセージが表示されること', async () => {\n    render(<SurveyAnswer />);\n\n    await waitFor(() => {\n      expect(screen.getByText('送信')).toBeInTheDocument();\n    });\n\n    fireEvent.click(screen.getByText('送信'));\n\n    await waitFor(() => {\n      expect(screen.getByText(/回答ありがとうございました/i)).toBeInTheDocument();\n    });\n  });\n\n  it('必須項目が未入力の場合にエラーが表示されること', async () => {\n    render(<SurveyAnswer />);\n\n    const emptySubmit = async () => {\n      fireEvent.submit(screen.getByRole('form'));\n    };\n\n    await waitFor(() => {\n      expect(emptySubmit).rejects.toThrow();\n    });\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-012",
      "category": "分析",
      "screenName": "アクセス分析画面",
      "description": "イベント告知ページのアクセス状況を分析する画面",
      "Screen components": "アクセス統計グラフ、登録数推移グラフ、フィルター設定",
      "operatingProcedure": "1. 期間の選択\n2. 分析項目の選択\n3. データのエクスポート",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/analytics.tsx",
      "getData": "[{table:'pageViews',items:['*']},{table:'registrations',items:['*']}]",
      "postData": "[]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"AnalyticsChart.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "アクセス分析画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-009",
          "category": "分析",
          "handleName": "アクセス統計取得",
          "description": "イベントページのアクセス統計データを取得",
          "handleProcedure": "1. 期間パラメータの解析\n2. アクセスログの集計\n3. 登録数推移データの取得\n4. データの集計処理\n5. 統計情報の返却",
          "fileName": "api/events/[eventId]/analytics/stats.ts",
          "relatedScreen": "SCR-012",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport '@testing-library/jest-dom';\nimport Analytics from '@/pages/events/[eventId]/analytics';\nimport userEvent from '@testing-library/user-event';\n\n// モックデータ\nconst mockAnalyticsData = {\n  pageViews: {\n    daily: [\n      { date: '2024-01-01', count: 100 },\n      { date: '2024-01-02', count: 150 }, \n    ],\n    total: 250\n  },\n  registrations: {\n    daily: [\n      { date: '2024-01-01', count: 10 },\n      { date: '2024-01-02', count: 15 },\n    ],\n    total: 25\n  }\n};\n\n// APIモック\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\nmockedAxios.get.mockResolvedValue({ data: mockAnalyticsData });\n\ndescribe('Analytics画面', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('初期表示時にデータを取得して表示する', async () => {\n    render(<Analytics />);\n    \n    await waitFor(() => {\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        expect.stringContaining('/api/events/'),\n        expect.any(Object)\n      );\n    });\n\n    expect(screen.getByText('アクセス分析')).toBeInTheDocument();\n    expect(screen.getByText('総アクセス数: 250')).toBeInTheDocument();\n    expect(screen.getByText('総登録数: 25')).toBeInTheDocument();\n  });\n\n  it('期間フィルターが機能する', async () => {\n    render(<Analytics />);\n    \n    const startDateInput = screen.getByLabelText('開始日');\n    const endDateInput = screen.getByLabelText('終了日');\n    \n    await userEvent.clear(startDateInput);\n    await userEvent.type(startDateInput, '2024-01-01');\n    await userEvent.clear(endDateInput);\n    await userEvent.type(endDateInput, '2024-01-02');\n    \n    const applyButton = screen.getByText('適用');\n    fireEvent.click(applyButton);\n\n    await waitFor(() => {\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        expect.stringContaining('startDate=2024-01-01'),\n        expect.any(Object)\n      );\n    });\n  });\n\n  it('エクスポートボタンが機能する', async () => {\n    render(<Analytics />);\n    \n    const exportButton = screen.getByText('CSVエクスポート');\n    fireEvent.click(exportButton);\n\n    await waitFor(() => {\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        expect.stringContaining('/export'),\n        expect.any(Object)\n      );\n    });\n  });\n\n  it('エラー時にエラーメッセージを表示する', async () => {\n    mockedAxios.get.mockRejectedValueOnce(new Error('API Error'));\n    \n    render(<Analytics />);\n\n    await waitFor(() => {\n      expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  it('グラフタイプの切り替えが機能する', async () => {\n    render(<Analytics />);\n\n    const dailyButton = screen.getByText('日別');\n    const weeklyButton = screen.getByText('週別');\n    \n    fireEvent.click(weeklyButton);\n    \n    await waitFor(() => {\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        expect.stringContaining('groupBy=weekly'),\n        expect.any(Object)\n      );\n    });\n\n    fireEvent.click(dailyButton);\n\n    await waitFor(() => {\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        expect.stringContaining('groupBy=daily'),\n        expect.any(Object)\n      );\n    });\n  });\n\n  it('ローディング状態を表示する', async () => {\n    mockedAxios.get.mockImplementationOnce(() => \n      new Promise(resolve => setTimeout(resolve, 1000))\n    );\n\n    render(<Analytics />);\n\n    expect(screen.getByText('データを読み込み中...')).toBeInTheDocument();\n\n    await waitFor(() => {\n      expect(screen.queryByText('データを読み込み中...')).not.toBeInTheDocument();\n    });\n  });\n\n  it('データが存在しない場合のメッセージを表示する', async () => {\n    mockedAxios.get.mockResolvedValueOnce({ \n      data: {\n        pageViews: { daily: [], total: 0 },\n        registrations: { daily: [], total: 0 }\n      }\n    });\n\n    render(<Analytics />);\n\n    await waitFor(() => {\n      expect(screen.getByText('データが存在しません')).toBeInTheDocument();\n    });\n  });\n\n  it('カスタム期間選択が機能する', async () => {\n    render(<Analytics />);\n\n    const customRangeButton = screen.getByText('カスタム期間');\n    fireEvent.click(customRangeButton);\n\n    const startDateInput = screen.getByLabelText('開始日');\n    const endDateInput = screen.getByLabelText('終了日');\n\n    await userEvent.clear(startDateInput);\n    await userEvent.type(startDateInput, '2024-01-01');\n    await userEvent.clear(endDateInput);\n    await userEvent.type(endDateInput, '2024-01-31');\n\n    const applyButton = screen.getByText('適用');\n    fireEvent.click(applyButton);\n\n    await waitFor(() => {\n      expect(mockedAxios.get).toHaveBeenCalledWith(\n        expect.stringMatching(/startDate=2024-01-01.*endDate=2024-01-31/),\n        expect.any(Object)\n      );\n    });\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-013",
      "category": "メール管理",
      "screenName": "リマインドメール設定画面",
      "description": "イベント参加者へのリマインドメールを設定する画面",
      "Screen components": "メール設定フォーム、送信スケジュール設定",
      "operatingProcedure": "1. メール内容の作成\n2. 送信タイミングの設定\n3. テスト送信\n4. 設定保存",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/reminder.tsx",
      "getData": "[{table:'events',items:['*']},{table:'reminderSettings',items:['*']}]",
      "postData": "[{table:'reminderSettings',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"ReminderForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "リマインドメール設定画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-008",
          "category": "メール通知",
          "handleName": "リマインドメール送信",
          "description": "設定されたスケジュールでリマインドメールを送信",
          "handleProcedure": "1. 送信対象イベントの取得\n2. メールテンプレートの取得\n3. 参加者リストの取得\n4. メール送信処理\n5. 送信履歴の記録",
          "fileName": "api/events/[eventId]/reminder/send.ts",
          "relatedScreen": "SCR-013",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport ReminderPage from '@/pages/events/[eventId]/reminder';\nimport { useRouter } from 'next/navigation';\nimport axios from 'axios';\n\n// モック\njest.mock('next/navigation');\njest.mock('axios');\nconst mockRouter = useRouter as jest.Mock;\n\ndescribe('ReminderPage', () => {\n  const mockEventId = 'test-event-id';\n  const mockEvent = {\n    id: mockEventId,\n    title: 'テストイベント',\n    description: 'テスト用のイベントです',\n    startDate: '2024-01-01',\n    endDate: '2024-01-02'\n  };\n\n  const mockReminderSettings = {\n    id: 'reminder-1',\n    eventId: mockEventId,\n    subject: 'リマインダー',\n    body: 'イベント開催が近づいてきました',\n    sendTiming: 24, // 24時間前\n    enabled: true\n  };\n\n  beforeEach(() => {\n    mockRouter.mockImplementation(() => ({\n      query: { eventId: mockEventId },\n      push: jest.fn()\n    }));\n\n    axios.get.mockImplementation((url) => {\n      if (url.includes('/api/events/')) {\n        return Promise.resolve({ data: mockEvent });\n      }\n      if (url.includes('/api/reminder-settings/')) {\n        return Promise.resolve({ data: mockReminderSettings });\n      }\n    });\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('ページが正しくレンダリングされること', async () => {\n    render(<ReminderPage />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('リマインドメール設定')).toBeInTheDocument();\n    });\n  });\n\n  test('フォームに初期値が設定されること', async () => {\n    render(<ReminderPage />);\n\n    await waitFor(() => {\n      expect(screen.getByLabelText('件名')).toHaveValue(mockReminderSettings.subject);\n      expect(screen.getByLabelText('本文')).toHaveValue(mockReminderSettings.body);\n      expect(screen.getByLabelText('送信タイミング')).toHaveValue(mockReminderSettings.sendTiming.toString());\n    });\n  });\n\n  test('フォームの送信が正しく動作すること', async () => {\n    axios.post.mockResolvedValue({ data: { success: true } });\n    \n    render(<ReminderPage />);\n\n    await waitFor(() => {\n      screen.getByLabelText('件名');\n    });\n\n    await userEvent.type(screen.getByLabelText('件名'), '新しい件名');\n    await userEvent.type(screen.getByLabelText('本文'), '新しい本文');\n    await userEvent.type(screen.getByLabelText('送信タイミング'), '48');\n\n    fireEvent.click(screen.getByText('保存'));\n\n    await waitFor(() => {\n      expect(axios.post).toHaveBeenCalledWith(`/api/events/${mockEventId}/reminder`, expect.any(Object));\n    });\n  });\n\n  test('テスト送信が正しく動作すること', async () => {\n    axios.post.mockResolvedValue({ data: { success: true } });\n    \n    render(<ReminderPage />);\n\n    await waitFor(() => {\n      screen.getByText('テスト送信');\n    });\n\n    fireEvent.click(screen.getByText('テスト送信'));\n\n    await waitFor(() => {\n      expect(axios.post).toHaveBeenCalledWith(`/api/events/${mockEventId}/reminder/test`, expect.any(Object));\n      expect(screen.getByText('テストメールを送信しました')).toBeInTheDocument();\n    });\n  });\n\n  test('エラー時にエラーメッセージが表示されること', async () => {\n    axios.post.mockRejectedValue({ response: { data: { message: 'エラーが発生しました' } } });\n    \n    render(<ReminderPage />);\n\n    await waitFor(() => {\n      screen.getByText('保存');\n    });\n\n    fireEvent.click(screen.getByText('保存'));\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n    });\n  });\n\n  test('無効な入力でバリデーションエラーが表示されること', async () => {\n    render(<ReminderPage />);\n\n    await waitFor(() => {\n      screen.getByLabelText('件名');\n    });\n\n    await userEvent.clear(screen.getByLabelText('件名'));\n    await userEvent.clear(screen.getByLabelText('本文'));\n    \n    fireEvent.click(screen.getByText('保存'));\n\n    await waitFor(() => {\n      expect(screen.getByText('件名は必須です')).toBeInTheDocument();\n      expect(screen.getByText('本文は必須です')).toBeInTheDocument();\n    });\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-014",
      "category": "ダッシュボード",
      "screenName": "主催者ダッシュボード",
      "description": "イベント主催者向けのダッシュボード画面",
      "Screen components": "イベント一覧、参加者統計、最近の活動",
      "operatingProcedure": "1. 開催中イベントの確認\n2. 各種統計の確認\n3. 通知の確認",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "dashboard/index.tsx",
      "getData": "[{table:'events',items:['*']},{table:'participants',items:['*']},{table:'notifications',items:['*']}]",
      "postData": "[]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"DashboardStats.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "主催者ダッシュボード",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-015",
      "category": "支払い管理",
      "screenName": "支払い管理画面",
      "description": "有料イベントの支払い状況を管理する画面",
      "Screen components": "支払い一覧、ステータス管理、検索フィルター",
      "operatingProcedure": "1. 支払い状況の確認\n2. 支払いステータスの更新\n3. 入金確認",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/payments.tsx",
      "getData": "[{table:'payments',items:['*']},{table:'participants',items:['*']}]",
      "postData": "[{table:'payments',items:['status']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"PaymentList.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "支払い管理画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": [
        {
          "id": "BAC-010",
          "category": "支払い管理",
          "handleName": "支払い状態更新",
          "description": "参加者の支払い状態を更新",
          "handleProcedure": "1. 支払い情報の確認\n2. 支払い状態の更新\n3. 入金確認メールの送信\n4. 更新履歴の記録\n5. 更新結果の返却",
          "fileName": "api/events/[eventId]/payments/update.ts",
          "relatedScreen": "SCR-015",
          "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport '@testing-library/jest-dom';\nimport PaymentManagementPage from '@/pages/events/[eventId]/payments';\nimport userEvent from '@testing-library/user-event';\n\n// モックデータ\nconst mockPayments = [\n  {\n    id: '1',\n    participantId: 'p1',\n    amount: 5000,\n    status: '未払い',\n    dueDate: '2024-01-31',\n    participantName: '山田太郎',\n    ticketType: '一般チケット'\n  },\n  {\n    id: '2', \n    participantId: 'p2',\n    amount: 3000,\n    status: '支払い済み',\n    dueDate: '2024-01-31',\n    participantName: '鈴木花子',\n    ticketType: '学生チケット'\n  }\n];\n\n// API モック\njest.mock('axios', () => ({\n  get: jest.fn(() => Promise.resolve({ data: mockPayments })),\n  put: jest.fn(() => Promise.resolve({ data: { success: true } }))\n}));\n\ndescribe('支払い管理画面', () => {\n  beforeEach(() => {\n    // URLパラメータのモック\n    const mockParams = new URLSearchParams({ eventId: 'event123' });\n    jest.spyOn(require('next/navigation'), 'useSearchParams').mockImplementation(() => mockParams);\n  });\n\n  test('支払い一覧が正しく表示される', async () => {\n    render(<PaymentManagementPage />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('山田太郎')).toBeInTheDocument();\n      expect(screen.getByText('鈴木花子')).toBeInTheDocument();\n    });\n  });\n\n  test('支払いステータスの更新が正しく動作する', async () => {\n    render(<PaymentManagementPage />);\n    \n    await waitFor(() => {\n      const statusButton = screen.getByRole('button', { name: '未払い' });\n      fireEvent.click(statusButton);\n    });\n\n    const updateButton = screen.getByRole('button', { name: '支払い済みに更新' });\n    fireEvent.click(updateButton);\n\n    await waitFor(() => {\n      expect(global.axios.put).toHaveBeenCalledWith(\n        '/api/events/event123/payments/1/status',\n        { status: '支払い済み' }\n      );\n    });\n  });\n\n  test('検索フィルターが正しく動作する', async () => {\n    render(<PaymentManagementPage />);\n\n    const searchInput = screen.getByPlaceholderText('参加者名で検索');\n    await userEvent.type(searchInput, '山田');\n\n    await waitFor(() => {\n      expect(screen.getByText('山田太郎')).toBeInTheDocument();\n      expect(screen.queryByText('鈴木花子')).not.toBeInTheDocument();\n    });\n  });\n\n  test('支払いステータスでフィルタリングできる', async () => {\n    render(<PaymentManagementPage />);\n\n    const statusFilter = screen.getByRole('combobox', { name: 'ステータスフィルター' });\n    fireEvent.change(statusFilter, { target: { value: '支払い済み' } });\n\n    await waitFor(() => {\n      expect(screen.queryByText('山田太郎')).not.toBeInTheDocument();\n      expect(screen.getByText('鈴木花子')).toBeInTheDocument();\n    });\n  });\n\n  test('エラー時にエラーメッセージが表示される', async () => {\n    global.axios.get.mockRejectedValueOnce(new Error('データの取得に失敗しました'));\n    \n    render(<PaymentManagementPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  test('CSV出力が正しく動作する', async () => {\n    render(<PaymentManagementPage />);\n\n    const exportButton = screen.getByRole('button', { name: 'CSV出力' });\n    fireEvent.click(exportButton);\n\n    const downloadLink = await waitFor(() => screen.getByRole('link', { name: 'ダウンロード' }));\n    expect(downloadLink).toHaveAttribute('download', '支払い一覧.csv');\n  });\n\n  test('ページネーションが正しく動作する', async () => {\n    render(<PaymentManagementPage />);\n\n    const nextButton = screen.getByRole('button', { name: '次へ' });\n    fireEvent.click(nextButton);\n\n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith(\n        '/api/events/event123/payments',\n        expect.objectContaining({ params: { page: 2 } })\n      );\n    });\n  });\n\n  test('一括更新機能が正しく動作する', async () => {\n    render(<PaymentManagementPage />);\n\n    const checkboxes = await screen.findAllByRole('checkbox');\n    fireEvent.click(checkboxes[0]);\n    fireEvent.click(checkboxes[1]);\n\n    const bulkUpdateButton = screen.getByRole('button', { name: '一括更新' });\n    fireEvent.click(bulkUpdateButton);\n\n    const confirmButton = screen.getByRole('button', { name: '確定' });\n    fireEvent.click(confirmButton);\n\n    await waitFor(() => {\n      expect(global.axios.put).toHaveBeenCalledWith(\n        '/api/events/event123/payments/bulk-update',\n        { paymentIds: ['1', '2'], status: '支払い済み' }\n      );\n    });\n  });\n});\n```"
        }
      ]
    },
    {
      "id": "SCR-016",
      "category": "シリーズ管理",
      "screenName": "シリーズイベント作成画面",
      "description": "複数回開催のシリーズイベントを作成する画面",
      "Screen components": "シリーズ設定フォーム、各回イベント設定",
      "operatingProcedure": "1. シリーズ全体の設定\n2. 各回の日程設定\n3. 各回の詳細設定\n4. 保存",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/series/create.tsx",
      "getData": "[]",
      "postData": "[{table:'eventSeries',items:['*']},{table:'events',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"SeriesForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "シリーズイベント作成画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-017",
      "category": "設定",
      "screenName": "アカウント設定画面",
      "description": "ユーザーアカウントの設定を管理する画面",
      "Screen components": "プロフィール設定、通知設定、API設定",
      "operatingProcedure": "1. プロフィール情報の編集\n2. パスワード変更\n3. 通知設定の変更",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "settings/account.tsx",
      "getData": "[{table:'users',items:['*']},{table:'userSettings',items:['*']}]",
      "postData": "[{table:'users',items:['*']},{table:'userSettings',items:['*']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"SettingsForm.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "アカウント設定画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-018",
      "category": "通知",
      "screenName": "通知一覧画面",
      "description": "システム通知やイベント関連の通知を表示する画面",
      "Screen components": "通知リスト、既読管理、フィルター",
      "operatingProcedure": "1. 通知の確認\n2. 既読マーク付け\n3. 通知のフィルタリング",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "notifications/index.tsx",
      "getData": "[{table:'notifications',items:['*']}]",
      "postData": "[{table:'notifications',items:['readStatus']}]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"NotificationList.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "通知一覧画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-019",
      "category": "ヘルプ",
      "screenName": "ヘルプセンター画面",
      "description": "システムの使い方ガイドやFAQを表示する画面",
      "Screen components": "ヘルプカテゴリー、検索機能、FAQリスト",
      "operatingProcedure": "1. カテゴリーの選択\n2. キーワード検索\n3. 記事の閲覧",
      "user": "全てのユーザー",
      "accessRight": "ゲストユーザー",
      "fileName": "help/index.tsx",
      "getData": "[{table:'helpArticles',items:['*']},{table:'helpCategories',items:['*']}]",
      "postData": "[]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"HelpSearch.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "ヘルプセンター画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    },
    {
      "id": "SCR-020",
      "category": "レポート",
      "screenName": "イベントレポート画面",
      "description": "イベントの実施結果をレポートする画面",
      "Screen components": "参加統計、アンケート結果、収支報告",
      "operatingProcedure": "1. レポート期間の選択\n2. レポート項目の選択\n3. PDFエクスポート",
      "user": "イベント主催者",
      "accessRight": "ログインユーザー",
      "fileName": "events/[eventId]/report.tsx",
      "getData": "[{table:'events',items:['*']},{table:'participants',items:['*']},{table:'surveyAnswers',items:['*']},{table:'payments',items:['*']}]",
      "postData": "[]",
      "commonComponent": "[\"Header.tsx\",\"Footer.tsx\",\"ReportGenerator.tsx\"]",
      "estimationCategory": "screen",
      "functionName": "イベントレポート画面",
      "target": true,
      "manMonth": {
        "requirementDefinition": "",
        "design": "",
        "implementation": "",
        "test": "",
        "release": "",
        "migration": ""
      },
      "relatedBackendHandles": []
    }
  ]
}
